use std::ops::Range;

use itertools::Itertools as _;
use nalgebra::Point;

use super::GridIndex;

/// A grid for isosurface extraction
///
/// `min` and `max` define the minimum and maximum points of the isosurface.
/// `resolution` is the distance between points in the grid.
///
/// The actual values returned by `Grid`'s methods might be below or above that,
/// to enable proper extraction of the surface.
#[derive(Debug)]
pub struct GridDescriptor {
    pub min: Point<f32, 3>,
    pub max: Point<f32, 3>,
    pub resolution: f32,
}

impl GridDescriptor {
    /// The number of points that will be generated by `points`
    pub fn num_points(&self) -> usize {
        let indices_x = indices(self.min.x, self.max.x, self.resolution);
        let indices_y = indices(self.min.y, self.max.y, self.resolution);
        let indices_z = indices(self.min.z, self.max.z, self.resolution);

        indices_x.end * indices_y.end * indices_z.end
    }

    /// Returns the grid points themselves
    ///
    /// The grid extends beyond the `min` and `max` values given to the
    /// constructor, so that the center of the outermost cubes are on the
    /// isosurface, or outside of it.
    pub fn points(
        &self,
    ) -> impl Iterator<Item = (GridIndex, Point<f32, 3>)> + '_ {
        let indices_x = indices(self.min.x, self.max.x, self.resolution);
        let indices_y = indices(self.min.y, self.max.y, self.resolution);
        let indices_z = indices(self.min.z, self.max.z, self.resolution);

        let indices = indices_x
            .cartesian_product(indices_y)
            .cartesian_product(indices_z)
            .map(|((x, y), z)| [x, y, z]);

        let points = indices
            .map(move |[x, y, z]| {
                (
                    [x, y, z],
                    [
                        index_to_coordinate(x, self.min.x, self.resolution),
                        index_to_coordinate(y, self.min.y, self.resolution),
                        index_to_coordinate(z, self.min.z, self.resolution),
                    ],
                )
            })
            .map(|(index, point)| (index, point.into()));

        points
    }
}

fn indices(min: f32, max: f32, resolution: f32) -> Range<usize> {
    let lower = 0;
    let upper = ((max - min) / resolution).ceil() as usize + 2;

    lower..upper
}

fn index_to_coordinate(index: usize, min: f32, resolution: f32) -> f32 {
    index as f32 * resolution + min - resolution / 2.0
}

#[cfg(test)]
mod tests {
    use super::GridDescriptor;

    #[test]
    fn num_points_should_return_number_of_points() {
        let grid = GridDescriptor {
            min: [0.0, 0.0, 0.5].into(),
            max: [0.5, 1.0, 1.5].into(),
            resolution: 1.0,
        };

        let num_points = grid.num_points();
        let points: Vec<_> = grid.points().collect();

        assert_eq!(num_points, points.len());
    }

    #[test]
    fn points_should_return_grid_points() {
        let grid = GridDescriptor {
            min: [0.0, 0.0, 0.5].into(),
            max: [0.5, 1.0, 1.5].into(),
            resolution: 1.0,
        };

        let points: Vec<_> = grid.points().collect();

        assert_eq!(
            points,
            vec![
                ([0, 0, 0], [-0.5, -0.5, 0.0].into()),
                ([0, 0, 1], [-0.5, -0.5, 1.0].into()),
                ([0, 0, 2], [-0.5, -0.5, 2.0].into()),
                ([0, 1, 0], [-0.5, 0.5, 0.0].into()),
                ([0, 1, 1], [-0.5, 0.5, 1.0].into()),
                ([0, 1, 2], [-0.5, 0.5, 2.0].into()),
                ([0, 2, 0], [-0.5, 1.5, 0.0].into()),
                ([0, 2, 1], [-0.5, 1.5, 1.0].into()),
                ([0, 2, 2], [-0.5, 1.5, 2.0].into()),
                ([1, 0, 0], [0.5, -0.5, 0.0].into()),
                ([1, 0, 1], [0.5, -0.5, 1.0].into()),
                ([1, 0, 2], [0.5, -0.5, 2.0].into()),
                ([1, 1, 0], [0.5, 0.5, 0.0].into()),
                ([1, 1, 1], [0.5, 0.5, 1.0].into()),
                ([1, 1, 2], [0.5, 0.5, 2.0].into()),
                ([1, 2, 0], [0.5, 1.5, 0.0].into()),
                ([1, 2, 1], [0.5, 1.5, 1.0].into()),
                ([1, 2, 2], [0.5, 1.5, 2.0].into()),
                ([2, 0, 0], [1.5, -0.5, 0.0].into()),
                ([2, 0, 1], [1.5, -0.5, 1.0].into()),
                ([2, 0, 2], [1.5, -0.5, 2.0].into()),
                ([2, 1, 0], [1.5, 0.5, 0.0].into()),
                ([2, 1, 1], [1.5, 0.5, 1.0].into()),
                ([2, 1, 2], [1.5, 0.5, 2.0].into()),
                ([2, 2, 0], [1.5, 1.5, 0.0].into()),
                ([2, 2, 1], [1.5, 1.5, 1.0].into()),
                ([2, 2, 2], [1.5, 1.5, 2.0].into()),
            ]
        );
    }
}
